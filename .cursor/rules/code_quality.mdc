---
description: Code quality standards and conventions
globs:
  - "**/*.py"
alwaysApply: true
---

## Code Quality

Code quality standards apply to all code written by the user or AI. This includes:
- Project source code (`src/`)
- Development tooling (`dev/`)
- Test utilities (`tests/utils/`)
- Test files (`tests/`)

Code quality standards do **not** apply to:
- Externally sourced code
- Generated code that is never manually edited (e.g., `dist/`, `bin/`)

### Line Length

Maximum 88 characters per line (enforced by Ruff). **Always fix violations; never ignore them.**

**Principle**: Prioritize readability and comprehension over simply meeting the character limit.

#### Comments and Strings

Do not shorten comments or string literals to meet the line length limit if doing so significantly hurts readability, comprehension, or content. Instead, split them across multiple lines.

**Comments:**
- **Original** (too long): `# Validate user input before processing to ensure data integrity and prevent security vulnerabilities`
- **Good shortening**: `# Validate user input before processing` (preserves important context)
- **Bad shortening**: `# Validate input before processing` (removed "user" - important context lost)
- **Split long comments** across multiple lines (preferred for very long comments):
  ```python
  # Validate user input before processing to ensure data integrity
  # and prevent security vulnerabilities.
  ```

**String literals:**
- **Original** (too long): `msg = "Invalid user input provided in the form submission"`
- **Good shortening**: `msg = "Invalid user input"` (preserves important context)
- **Bad shortening**: `msg = "Invalid input"` (removed "user" - important context lost)
- **Split long strings** using parentheses for implicit line continuation (preferred for very long strings):
  ```python
  error_message = (
      "Failed to validate user input. Please check the format "
      "and ensure all required fields are present."
  )
  ```

#### Inline Statements

When inline statements (ternary expressions, comprehensions, generator expressions) exceed the line length limit, consider whether to wrap them across multiple lines or refactor into explicit if/else blocks or loops.

**Ternary expressions (conditional expressions):**
- **Original** (too long): `result = "success" if validate_user_input(data) and check_permissions(user) and process_data(data) else "failure"`
- **Wrapped** (split across lines):
  ```python
  result = (
      "success"
      if validate_user_input(data) and check_permissions(user) and process_data(data)
      else "failure"
  )
  ```
- **Refactored** (explicit if/else - preferred for complex conditions):
  ```python
  if validate_user_input(data) and check_permissions(user) and process_data(data):
      result = "success"
  else:
      result = "failure"
  ```

**Comprehensions (list/dict/set comprehensions):**
- **Original** (too long): `handler_types = {type(h).__name__ for h in typed_logger.handlers if isinstance(h, FileHandler) and h.level >= logging.WARNING}`
- **Wrapped** (split across lines):
  ```python
  handler_types = {
      type(h).__name__
      for h in typed_logger.handlers
      if isinstance(h, FileHandler) and h.level >= logging.WARNING
  }
  ```
- **Refactored** (explicit loop - preferred for complex logic):
  ```python
  handler_types = set()
  for h in typed_logger.handlers:
      if isinstance(h, FileHandler) and h.level >= logging.WARNING:
          handler_types.add(type(h).__name__)
  ```

**Generator expressions (in function calls):**
- **Original** (too long): `if all(i < len(list(p.parts)) and list(p.parts)[i] == part for p in resolved_paths[1:]):`
- **Wrapped** (split across lines):
  ```python
  if all(
      i < len(list(p.parts)) and list(p.parts)[i] == part
      for p in resolved_paths[1:]
  ):
  ```
- **Refactored** (explicit loop - preferred for complex conditions):
  ```python
  all_match = True
  for p in resolved_paths[1:]:
      if not (i < len(list(p.parts)) and list(p.parts)[i] == part):
          all_match = False
          break
  if all_match:
  ```

### Python Version

**Minimum version**: Python 3.10. All code must work on Python 3.10 and must never break when run there.

**Using newer features**: You may use features from Python 3.11+ as long as you can support them in both Python 3.10 and the newer version. Acceptable approaches include:
- `from __future__` imports
- `typing_extensions` for type hints
- Backported implementations of newer functionality

**Backporting strategy**: When a newer Python feature behaves differently or is unavailable in Python 3.10, **encapsulate the version differences in a function** so the calling code stays clean. The function handles the Python version detection internally and provides a consistent interface. Document the backport clearly, noting that it can be removed when the minimum Python version is bumped.

**Examples**:
- `fnmatch()` behaves differently in Python 3.10 vs 3.11+. We encapsulate this in `fnmatch_portable()` which uses `fnmatch()` in 3.11+ and a backported implementation for Python 3.10 (which may be slower but maintains compatibility). Calling code uses `fnmatch_portable()` without needing to know about version differences.
- TOML loading uses `load_toml()` which internally uses `tomllib` (built-in) in Python 3.11+ and the optional `tomli` library in Python 3.10. Calling code uses `load_toml()` without needing to handle version differences.

**Backport size limit**: Do not introduce a backport if the implementation would be large (more than roughly a few hundred lines of code).

**When to ask the developer**: If a modern feature exists that cannot be easily backported (due to size or complexity), **always ask the developer** for guidance on how to proceed. Do not make this decision yourself. The developer may choose to use a wrapper function (like `load_toml()`) that uses different libraries for different Python versions, or may decide on another approach.

### Static checks, Type Checking, Formatting, Linting, and Tests

**Requirement**: All code must pass `poetry run poe check:fix` **EVEN if the errors do not appear related to the work currently being done**. This command must be re-run every time until it is completely clean. It runs Static checks, Formatting, Type Checking, Linting, and Tests in both package and stitched runtimes.

**CI requirement**: `poetry run poe check:fix` must pass for CI to pass. **You cannot push code until this is resolved.**

For guidance on resolving type checking errors, see `type_checking.mdc`.

#### Available Commands

You can run individual tools using `poetry run poe <command>` (including `poetry run poe python`), but **before finishing a task, `poetry run poe check:fix` must complete successfully**.

**Main commands:**
- `poetry run poe check:fix` - Run all checks (fix, typecheck, test) - **must pass before completing work**
- `poetry run poe check` - Run all checks without fixing (lint, typecheck, test)
- `poetry run poe fix` - Auto-fix formatting and linting issues
- `poetry run poe lint` - Run linting checks only
- `poetry run poe typecheck` - Run type checking (mypy + pyright)
- `poetry run poe test` - Run test suite in both package and stitched runtimes

**Individual tool commands:**
- `poetry run poe lint:ruff` - Run ruff linting checks
- `poetry run poe fix:ruff:package` - Auto-fix ruff linting issues
- `poetry run poe fix:format:package` - Format code with ruff
- `poetry run poe typecheck:mypy` - Run mypy type checking
- `poetry run poe typecheck:pyright` - Run pyright type checking
- `poetry run poe test:pytest:package` - Run tests in package runtime mode
- `poetry run poe test:pytest:script` - Run tests in stitched runtime mode

**Running tools on specific files:**
- Format a single file: `poetry run ruff format src/serger/build.py`
- Check a single file: `poetry run ruff check src/serger/build.py`
- Fix a single file: `poetry run ruff check --fix src/serger/build.py`
- Run a specific test (package mode): `poetry run pytest tests/9_integration/test_log_level.py::test_specific_function`
- Run a specific test (stitched mode): `RUNTIME_MODE=stitched poetry run pytest tests/9_integration/test_log_level.py::test_specific_function`

#### Checkpoint Commits

You **CAN** check in code as a checkpoint after fixing most errors, and the AI can suggest doing so. **When committing, follow the conventions in `git_conventions.mdc`.** If you do this, the AI should write a prompt for opening a new chat to continue with the remaining fixes. The prompt should contain:

1. **Context**: Brief description of what was being worked on
2. **Current status**: What has been fixed and what remains
3. **Remaining issues**: List of specific errors or test failures that still need to be addressed
4. **Next steps**: What needs to be done to get `poetry run poe check:fix` passing
5. **Files changed**: List of files that were modified in this checkpoint

**Example prompt for new chat:**
```
I'm working on [feature/change description]. I've made a checkpoint commit after fixing most issues, but `poetry run poe check:fix` still has [X] remaining errors.

**Fixed:**
- [List of what was fixed]

**Remaining issues:**
- [Specific error messages or test failures]
- [Files that still need work]

**Next steps:**
- [What needs to be done]

**Files modified:**
- [List of changed files]

Please help me resolve the remaining issues to get `poetry run poe check:fix` passing.
```

### Test Module Naming

**Duplicate test module names**: When type checkers (mypy) report duplicate module names across different test directories (e.g., `tests/5_core/test_main_config.py` and `tests/9_integration/test_main_config.py`), **always rename the test files** to avoid conflicts rather than excluding them from type checking.

**Rationale**:
- Renaming maintains proper test organization and makes test purposes clear
- Excluding files from type checking reduces type safety coverage
- Descriptive names (e.g., `test_main_config_integration.py` vs `test_main_config.py`) improve code clarity

**Approach**:
1. Identify which test file should be renamed (typically the integration test or the newer one)
2. Choose a descriptive name that distinguishes it from the other (e.g., add `_integration`, `_unit`, or a specific feature suffix)
3. Update the file header comment to reflect the new name
4. Remove any type checker exclusions that were added as a workaround
5. Verify tests still run correctly with the new name

**Example**:
- ❌ **Bad**: Exclude `tests/9_integration/test_main_config.py` from mypy checking
- ✅ **Good**: Rename `tests/9_integration/test_main_config.py` to `tests/9_integration/test_main_config_integration.py`
